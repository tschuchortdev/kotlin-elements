package com.tschuchort.kotlinelements

import com.tschuchort.kotlinelements.from_metadata.*
import com.tschuchort.kotlinelements.getKotlinMetadata
import com.tschuchort.kotlinelements.isSimpleObjectClass
import com.tschuchort.kotlinelements.mixins.*
import kotlinx.metadata.KmClass
import kotlinx.metadata.KmTypeParameter
import kotlinx.metadata.jvm.KotlinClassMetadata
import java.util.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.element.*

internal object KJTypeElementFactory {
	private val convertedTypeElemsCache = Collections.synchronizedMap(LruCache<TypeElement, ConvertedTypeAndMembers>(255))

	abstract class ConvertedTypeAndMembers {
		abstract val convertedType: KJTypeElement
		abstract val convertedMembers: Map<Element, KJElement>
	}

	fun convertType(elem: TypeElement, processingEnv: ProcessingEnvironment): ConvertedTypeAndMembers {
		/* Because TypeElements are required to convert their members and converting those
			members is expensive, we cache the converted TypeElements so that the user can
			simply iterate over members and convert them one-by-one without having to worry
			about re-converting the enclosing TypeElement every time */
		return convertedTypeElemsCache[elem] ?: when (val metadata = elem.getKotlinMetadata()) {
			is KotlinClassMetadata.Class -> {
				convertFoo(elem, metadata.toKmClass(), processingEnv)
			}
			is KotlinClassMetadata.FileFacade           -> KmFileFacadeElement(
					elem,
					metadata.toKmPackage(),
					processingEnv
			)
			is KotlinClassMetadata.MultiFileClassFacade -> KmMultiFileClassFacadeElement(
					elem,
					metadata.partClassNames,
					processingEnv
			)
			/*  Represents metadata of a class file containing a compiled multi-file class part, i.e. an internal class with method bodies
			* and their metadata, accessed only from the corresponding facade. */
			is KotlinClassMetadata.MultiFileClassPart   -> throw AssertionError(
					"Element $this is a MultiFileClassPart but this shouldn't be possible " +
							"because MultiFileClassParts are synthetic and thus are never loaded " +
							"by the annotation processor."
			)
			/* Represents metadata of a class file containing a synthetic class, e.g. a class for lambda, `$DefaultImpls` class for interface
			 * method implementations, `$WhenMappings` class for optimized `when` over enums, etc. */
			is KotlinClassMetadata.SyntheticClass       -> KotlinSyntheticClassElement()
			/* Represents metadata of an unknown class file. This class is used if an old version of this library is used against a new kind
			 * of class files generated by the Kotlin compiler, unsupported by this library. */
			is KotlinClassMetadata.Unknown              -> throw AssertionError("Element $elem has unknown kotlin metadata: $metadata.")
		}
	}

	private fun convertFoo(elem: TypeElement, metadataClass: KmClass?,
										   processingEnv: ProcessingEnvironment): KJTypeElement {
		val typeElementDelegate = KJTypeElement.createDelegate(elem, null, processingEnv)
		val typeParamsDelegate = HasTypeParameters.createDelegateWithoutMetadata(elem.typeParameters, processingEnv)
		val modalityDelegate = object : HasModality {
			override val modality =
				metadataClass?.flags?.let { KJModality.fromKm(it) } ?: KJModality.fromJavax(elem)
		}

		return when (elem.kind!!) {
			ElementKind.CLASS           ->
				if (metadataClass?.isSimpleObjectClass() == true
					|| metadataClass?.isCompanionObjectClass() == true) {

					object : KJObjectElement(),
							 KJTypeElement_ by typeElementDelegate,
							 HasTypeParameters by typeParamsDelegate,
							 HasModality by modalityDelegate {
						override val isCompanion: Boolean = metadataClass.isCompanionObjectClass()
						override val origin: KJOrigin.Kotlin.Declared = super<KJObjectElement>.origin
					}
				}
				else {
					object : KJClassElement(),
							 KJTypeElement_ by typeElementDelegate,
							 HasTypeParameters by typeParamsDelegate,
							 HasModality by modalityDelegate {
						override val isInner: Boolean =
							elem.enclosingElement?.kind?.isClass ?: false && elem.modifiers.contains(Modifier.STATIC)
					}
				}
			ElementKind.INTERFACE       -> object : KJInterfaceElement(),
													KJTypeElement_ by typeElementDelegate,
													HasTypeParameters by typeParamsDelegate,
													HasModality by modalityDelegate {
			}

			ElementKind.ENUM            -> object : KJEnumElement(),
													KJTypeElement_ by typeElementDelegate,
													HasModality by modalityDelegate {
				override val constants: Set<KJEnumConstantElement> by lazy {
					enclosedElements.map { it as KJEnumConstantElement }.toSet()
				}
			}

			ElementKind.ANNOTATION_TYPE -> object : KJAnnotationElement(),
													KJTypeElement_ by typeElementDelegate {

				override val attributes: List<KJAnnotationAttributeElement> by lazy {
					enclosedElements.mapNotNull { it as? KJAnnotationAttributeElement }
				}

				override val interfaces: Set<Nothing>
					get() = super<KJAnnotationElement>.interfaces

				override val superclass: Nothing?
					get() = super<KJAnnotationElement>.superclass
			}

			else                        -> throw AssertionError("ElementKind is not a type: ${elem.kind}")
		}
	}

internal fun KJElement.Companion.createDelegate(
		elem: Element, processingEnv: ProcessingEnvironment
): KJElement_ = object : KJElement_, AnnotatedConstruct by elem  {
	override val enclosingElement: KJElement? by lazy {
		elem.enclosingElement?.toKJElement(processingEnv)
	}

	override val enclosedElements: Set<KJElement> by lazy {
		elem.enclosedElements.mapNotNull { it.toKJElement(processingEnv) }.toSet()
	}

	override val simpleName = elem.simpleName.toString()

	override fun asTypeMirror(): KJTypeMirror? = elem.asType()?.toKJTypeMirror(processingEnv)

	override fun asJavaxElement(): Element = elem

	override val origin = KJOrigin.fromJavax(elem, processingEnv)
}

internal fun KJTypeElement.Companion.createDelegate(
		elem: TypeElement, metadataClass: KmClass?, processingEnv: ProcessingEnvironment
): KJTypeElement_ {
	val elementDelegate = KJElement.createDelegate(elem, processingEnv)

	return object : KJTypeElement_, KJElement_ by elementDelegate {

		override val interfaces: Set<KJTypeMirror> by lazy {
			elem.interfaces.mapNotNull { it.toKJTypeMirror(processingEnv) }.toSet()
		}

		override val superclass: KJTypeMirror? by lazy {
			elem.superclass?.toKJTypeMirror(processingEnv)
		}

		override val enclosedElements: Set<KJElement> by lazy {
			TODO()
		}

		override val visibility =
			metadataClass?.flags?.let { KJVisibility.fromKm(it) }
				?: KJVisibility.fromJavax(elem)

		override val qualifiedName = elem.qualifiedName.toString()

		override fun asJavaxElement(): TypeElement =
			elementDelegate.asJavaxElement() as TypeElement

		override val enclosingElement: KJElement
			get() = elementDelegate.enclosingElement!!
	}
}

internal fun HasTypeParameters.Companion.createDelegateWithoutMetadata(
		javaxTypeParams: List<TypeParameterElement>,
		processingEnv: ProcessingEnvironment
): HasTypeParameters = object : HasTypeParameters {
	override val typeParameters: List<KJTypeParameterElement> by lazy {
		javaxTypeParams.map { it.toKJElement(processingEnv) }
	}
}

internal fun HasTypeParameters.Companion.createDelegateWithMetadata(
		javaxTypeParams: List<TypeParameterElement>,
		kmTypeParams: List<KmTypeParameter>,
		enclosingKjElement: KJElement,
		processingEnv: ProcessingEnvironment
): HasTypeParameters = object : HasTypeParameters {
	init {
		check(kmTypeParams.size == javaxTypeParams.size) {
			"List of metadata type parameters should be the same length as list of Javax type parameters"
		}
	}

	override val typeParameters: List<KJTypeParameterElement> by lazy {
		kmTypeParams.zipWith(javaxTypeParams) { kmTypeParam, javaxTypeParam ->
			if (doTypeParamsMatch(javaxTypeParam, kmTypeParam)) {
				TODO()
			}
			else {
				throw AssertionError("Metadata type parameter should always match up with Javax type parameter")
			}
		}
	}

	private fun doTypeParamsMatch(typeParamElem: TypeParameterElement, kmTypeParam: KmTypeParameter): Boolean
			= (typeParamElem.simpleName.toString() == kmTypeParam.name)
}

